//
// Souffle - A Datalog Compiler
// Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved
// Licensed under the Universal Permissive License v 1.0 as shown at:
// - https://opensource.org/licenses/UPL
// - <souffle root>/licenses/SOUFFLE-UPL.txt

 and/or its affiliates.
//
// All rights reserved.
//

// This program can represent OUT = GEN U {IN - KILL} dataflow problems
// Since Datalog doesn't support removal of facts, as required by set substraction, the program computes:
// OUT = GEN U {IN and NKILL}

.type String
.type Integer

.type Procedure = String
.type Node = String
.type DataFlowFact = String

.decl StartNode(n:Node) input
.decl ReturnNode(n:Node) input
.decl Procedure(p:Procedure) input
.decl Node(n:Node) input
.decl DataFlowFact(f:DataFlowFact) input

//EDB relations

//Intraprocedural edge from m to n in procedure p
.decl e0(p:Procedure, m:Node, n:Node) input

//Call-to-return edge between call node m and after-return node n in procedure p
.decl e1(p:Procedure, m:Node, n:Node) input

//Data-flow function on edge(m,n) where nkill is a fact that is NOT killed 
.decl f_nk(p:Procedure, m:Node, n:Node, nkill:DataFlowFact) input

//Data-flow function on edge(m,n) where gen is a fact that is generated
.decl f_g(p:Procedure, m:Node, n:Node, gen:DataFlowFact) input

//Node m in procedure p calls procedure q
.decl call_site(p:Procedure, q:Procedure, m:Node) input

//Actual parameter in position i of call site m in procedure p is x
.decl Actual(p:Procedure, m:Node, i:Integer, x:DataFlowFact) input

//Formal parameter in position i of procedure p is y
.decl Formal(q:Procedure, i:Integer, y:DataFlowFact) input

//IDB relations

//Data-flow function on edge(m,n) where nkill is a fact that is NOT killed 
.decl phi_nk(p:Procedure, n:Node, nkill:DataFlowFact) output

//Data-flow function on edge(m,n) where gen is a fact that is generated
.decl phi_g(p:Procedure, n:Node, gen:DataFlowFact) output

//Data-flow fact x holds at node n of procedure p
.decl out(p:Procedure, n:Node, x:DataFlowFact) output


//Initialization: start nodes don't kill anything
phi_nk(p, s, x) :- Procedure(p),
                   Node(s),
                   DataFlowFact(x),
                   StartNode(s).


//Intra-procedural summaries

//X is in the nkill set of N if X is in phi_nk(M) and N doesn't kill X
phi_nk(p, n, x) :- e0(p, m, n),
                   f_nk(p, m, n, x),
                   phi_nk(p, m, x).

//X is in the gen set of N if X is in phi_g(M) and N doesn't kill X
phi_g(p, n, x) :- e0(p, m, n),
                  f_nk(p, m, n, x),
                  phi_g(p, m, x).

//X is in the gen set of N if N gen X
phi_g(p, n, x) :- e0(p, m, n),
                  f_g(p, m, n, x).
				  
				  				  
//Inter-procedural summaries
//X is in the nkill set of N if there is a call-to-return edge from M to N,
//M calls Q, M doesn't kill X and the return node of Q doesn't kill X 
phi_nk(p, n, x) :- e1(p, m, n),
                   call_site(p, q, m),
                   phi_nk(p, m, x),
                   phi_nk(q, r, x),
                   ReturnNode(r).

//X is in the gen set of N if there is a call-to-return edge from M to N,
//M calls Q, M generates X and the return node of Q doesn't kill X
phi_g(p, n, x) :- e1(p, m, n),
                  call_site(p, q, m),
                  phi_g(p, m, x),
                  phi_nk(q, r, x),
                  ReturnNode(r).

//X is in the gen set of N if there is a call-to-return edge from M to N,
//M calls Q and the return node of Q generates X
phi_g(p, n, x) :- e1(p, m, n),
                  call_site(p, q, m),
                  phi_g(q, r, x),
                  ReturnNode(r).
				  

//Encoding of the OUT relation

//X holds at start of Q if P calls Q, X holds at the start of P and X is not killed at the callsite. (IN AND NKILL)
out(q, s, x) :- call_site(p, q, c),
                out(p, s, x),
                phi_nk(p, c, x),
                StartNode(s).

//X holds at start of Q if P calls Q at site C and C generates X. (U GEN)
out(q, s, x) :- call_site(p, q, c),
                phi_g(p, c, x),
                StartNode(s).

//X holds at N in P if X holds at the start of P and X is not killed at N (IN AND NKILL)
out(p, n, x) :- out(p, s, x),
                phi_nk(p, n, x),
                StartNode(s),
                !StartNode(n).

//X holds at N in P if X is generated by N (U GEN)
out(p, n, x) :- phi_g(p, n, x),
                !StartNode(n).
